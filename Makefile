# ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
#   üîç LOCAL GIT ANALYZER - Makefile
#   (An MCP server for analyzing local Git repositories)
# ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
#
# Description: Build & automation helpers for the Local Git Analyzer project
# Usage: run `make` or `make help` to view available targets
#
# help: üîç LOCAL GIT ANALYZER  (An MCP server for analyzing local Git repositories)
#
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Project variables
PROJECT_NAME      = local-git-analyzer
PACKAGE_NAME      = local_git_analyzer
DOCS_DIR          = docs
HANDSDOWN_PARAMS  = -o $(DOCS_DIR)/ -n $(PACKAGE_NAME) --name "Local Git Analyzer" --cleanup

TEST_DOCS_DIR ?= $(DOCS_DIR)/docs/test

# Project-wide clean-up targets
DIRS_TO_CLEAN := __pycache__ .pytest_cache .tox .ruff_cache .pyre .mypy_cache .pytype \
                 dist build site .eggs *.egg-info .cache htmlcov certs \
                 $(VENV_DIR).sbom $(COVERAGE_DIR) \
                 node_modules coverage_report test-reports cache

FILES_TO_CLEAN := .coverage coverage.xml profile.prof profile.pstats \
                  $(PROJECT_NAME).sbom.json \
                  snakefood.dot packages.dot classes.dot \
                  $(DOCS_DIR)/pstats.png \
                  $(DOCS_DIR)/docs/test/sbom.md \
                  $(DOCS_DIR)/docs/test/{unittest,full,index,test}.md \
				  $(DOCS_DIR)/docs/images/coverage.svg $(LICENSES_MD) $(METRICS_MD) \
				  *.log *.txt *.png *.pkl

COVERAGE_DIR ?= $(DOCS_DIR)/docs/coverage
LICENSES_MD  ?= $(DOCS_DIR)/docs/test/licenses.md
METRICS_MD   ?= $(DOCS_DIR)/docs/metrics/loc.md

# -----------------------------------------------------------------------------
# Container resource configuration
CONTAINER_MEMORY = 2048m
CONTAINER_CPUS   = 2

# Virtual-environment variables
VENVS_DIR := $(HOME)/.venv
VENV_DIR  := $(VENVS_DIR)/$(PROJECT_NAME)

# Poetry configuration
POETRY_VENV := $(shell poetry env info --path 2>/dev/null || echo "")

# =============================================================================
# üìñ DYNAMIC HELP
# =============================================================================
.PHONY: help
help:
	@grep "^# help\:" Makefile | grep -v grep | sed 's/\# help\: //' | sed 's/\# help\://'

# =============================================================================
# üå± VIRTUAL ENVIRONMENT & INSTALLATION
# =============================================================================
# help: üå± VIRTUAL ENVIRONMENT & INSTALLATION
# help: venv                 - Create a fresh virtual environment with Poetry
# help: activate             - Show how to activate the virtual environment
# help: install              - Install project dependencies with Poetry
# help: install-dev          - Install project (incl. dev deps) with Poetry
# help: update               - Update all installed deps with Poetry
# help: poetry-install       - Install Poetry if not present
.PHONY: venv activate install install-dev update poetry-install

poetry-install:
	@if ! command -v poetry >/dev/null 2>&1; then \
		echo "üì¶ Installing Poetry..."; \
		curl -sSL https://install.python-poetry.org | python3 -; \
		echo "‚úÖ Poetry installed. You may need to restart your shell."; \
	else \
		echo "‚úÖ Poetry is already installed."; \
	fi

venv: poetry-install
	@echo "üå± Creating virtual environment with Poetry..."
	@poetry env remove --all 2>/dev/null || true
	@poetry install --no-dev
	@echo "‚úÖ Virtual environment created with Poetry."
	@echo "üí° Activate with: poetry shell"

activate:
	@echo "üí° To activate the virtual environment, use one of:"
	@echo "    poetry shell"
	@echo "    source $$(poetry env info --path)/bin/activate"

install: poetry-install
	@echo "üì¶ Installing project dependencies..."
	@poetry install --no-dev

install-dev: poetry-install
	@echo "üì¶ Installing project with dev dependencies..."
	@poetry install

update: poetry-install
	@echo "‚¨ÜÔ∏è Updating dependencies..."
	@poetry update

# help: check-env            - Verify all required env vars are present
.PHONY: check-env
check-env:
	@echo "üîé Checking environment variables..."
	@if [ -f ".env" ]; then \
		echo "‚úÖ .env file found"; \
	else \
		echo "‚ö†Ô∏è  No .env file found"; \
	fi

# =============================================================================
# ‚ñ∂Ô∏è SERVE & TESTING
# =============================================================================
# help: ‚ñ∂Ô∏è SERVE & TESTING
# help: serve                - Run MCP server with poetry
# help: serve-http           - Run HTTP server on port 8000
# help: dev                  - Run in development mode with auto-reload
# help: run                  - Execute the main application
# help: test                 - Run unit tests with pytest
# help: test-integration     - Run integration tests
# help: test-all             - Run all tests (unit + integration)
# help: test-manual          - Run manual tests
# help: test-quick           - Run quick tests only

.PHONY: serve serve-http dev run test test-integration test-all test-manual test-quick

serve:
	@echo "üöÄ Starting MCP server..."
	poetry run python -m $(PACKAGE_NAME)

serve-http:
	@echo "üåê Starting HTTP server on port 8000..."
	poetry run python -m $(PACKAGE_NAME).run_http_server

dev:
	@echo "üîÑ Running in development mode..."
	poetry run python -m $(PACKAGE_NAME) --dev

run:
	@echo "‚ñ∂Ô∏è Running application..."
	poetry run python -m $(PACKAGE_NAME)

test:
	@echo "üß™ Running unit tests..."
	poetry run pytest tests/unit/ -v --tb=short

test-integration:
	@echo "üß™ Running integration tests..."
	poetry run pytest tests/integration/ -v --tb=short

test-all:
	@echo "üß™ Running all tests..."
	poetry run pytest tests/ -v --tb=short

test-manual:
	@echo "üß™ Running manual tests..."
	poetry run pytest tests/test_manual.py -v --tb=short

test-quick:
	@echo "üß™ Running quick tests..."
	poetry run pytest tests/integration/test_quick.py -v --tb=short

# =============================================================================
# üßπ CLEANUP
# =============================================================================
# help: üßπ CLEANUP
# help: clean                - Remove caches, build artifacts, and temp files
# help: clean-all            - Deep clean including virtual environments

.PHONY: clean clean-all

clean:
	@echo "üßπ Cleaning workspace..."
	@# Remove matching directories
	@for dir in $(DIRS_TO_CLEAN); do \
		find . -type d -name "$$dir" -exec rm -rf {} + 2>/dev/null || true; \
	done
	@# Remove listed files
	@rm -f $(FILES_TO_CLEAN) 2>/dev/null || true
	@# Delete Python bytecode
	@find . -name '*.py[cod]' -delete 2>/dev/null || true
	@echo "‚úÖ Clean complete."

clean-all: clean
	@echo "üßπ Deep cleaning including Poetry environment..."
	@poetry env remove --all 2>/dev/null || true
	@echo "‚úÖ Deep clean complete."

# =============================================================================
# üìä COVERAGE & METRICS
# =============================================================================
# help: üìä COVERAGE & METRICS
# help: coverage             - Run tests with coverage reporting
# help: coverage-html        - Generate HTML coverage report
# help: coverage-report      - Show coverage report in terminal
# help: pip-licenses         - Generate dependency license inventory
# help: scc                  - Quick LoC/complexity snapshot with scc
# help: scc-report           - Generate detailed LoC metrics

.PHONY: coverage coverage-html coverage-report pip-licenses scc scc-report

coverage:
	@echo "üìä Running tests with coverage..."
	@mkdir -p $(TEST_DOCS_DIR)
	poetry run pytest --cov=$(PACKAGE_NAME) --cov-report=term --cov-report=xml --cov-report=html:$(COVERAGE_DIR) tests/
	@echo "‚úÖ Coverage report generated."

coverage-html:
	@echo "üìä Generating HTML coverage report..."
	poetry run pytest --cov=$(PACKAGE_NAME) --cov-report=html:$(COVERAGE_DIR) tests/
	@echo "‚úÖ HTML coverage report: $(COVERAGE_DIR)/index.html"

coverage-report:
	@echo "üìä Showing coverage report..."
	poetry run coverage report -m

pip-licenses:
	@echo "üìú Generating license inventory..."
	@mkdir -p $(dir $(LICENSES_MD))
	poetry run pip-licenses --format=markdown --with-authors --with-urls > $(LICENSES_MD)
	@echo "üìú License inventory written to $(LICENSES_MD)"

scc:
	@echo "üìä Code complexity analysis..."
	@if command -v scc >/dev/null 2>&1; then \
		scc --by-file -i py .; \
	else \
		echo "‚ùå scc not installed. Install with: go install github.com/boyter/scc/v3@latest"; \
	fi

scc-report:
	@echo "üìä Generating detailed LoC report..."
	@mkdir -p $(dir $(METRICS_MD))
	@if command -v scc >/dev/null 2>&1; then \
		printf "# Lines of Code Report\n\n" > $(METRICS_MD); \
		scc . --format=html-table >> $(METRICS_MD); \
		printf "\n\n## Per-file metrics\n\n" >> $(METRICS_MD); \
		scc -i py,yaml,toml,md --by-file . --format=html-table >> $(METRICS_MD); \
		echo "üìä LoC metrics captured in $(METRICS_MD)"; \
	else \
		echo "‚ùå scc not installed. Install with: go install github.com/boyter/scc/v3@latest"; \
	fi

# =============================================================================
# üîç LINTING & STATIC ANALYSIS
# =============================================================================
# help: üîç LINTING & STATIC ANALYSIS
# help: lint                 - Run the full linting suite
# help: black                - Format code with black
# help: isort                - Sort imports with isort
# help: flake8               - Run flake8 checks
# help: pylint               - Run pylint analysis
# help: mypy                 - Run mypy type checking
# help: bandit               - Security scan with bandit
# help: ruff                 - Run ruff linter and formatter
# help: pre-commit           - Run pre-commit hooks

# List of individual lint targets
LINTERS := black isort flake8 pylint mypy bandit ruff

.PHONY: lint $(LINTERS) pre-commit

lint:
	@echo "üîç Running full lint suite (checks only)..."
	@set -e; for linter in $(LINTERS); do \
		if [ "$$linter" = "ruff" ]; then \
			echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"; \
			echo "‚Ä¢ $$linter (check only)"; \
			poetry run ruff check $(PACKAGE_NAME) tests/ || echo "‚ö†Ô∏è $$linter failed"; \
		else \
			echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"; \
			echo "‚Ä¢ $$linter"; \
			$(MAKE) $$linter || echo "‚ö†Ô∏è $$linter failed"; \
		fi \
	done

.PHONY: black isort flake8 pylint mypy bandit ruff pre-commit

black:
	@echo "üé® Formatting with black..."
	poetry run black $(PACKAGE_NAME) tests/

isort:
	@echo "üîÄ Sorting imports with isort..."
	poetry run isort $(PACKAGE_NAME) tests/

flake8:
	@echo "üêç Running flake8..."
	poetry run flake8 $(PACKAGE_NAME) tests/

pylint:
	@echo "üêõ Running pylint..."
	poetry run pylint $(PACKAGE_NAME)

mypy:
	@echo "üè∑Ô∏è Running mypy type checking..."
	poetry run mypy $(PACKAGE_NAME)

bandit:
	@echo "üõ°Ô∏è Running bandit security scan..."
	poetry run bandit -r $(PACKAGE_NAME)

ruff:
	@echo "‚ö° Running ruff..."
	poetry run ruff check $(PACKAGE_NAME) tests/
	poetry run ruff format $(PACKAGE_NAME) tests/

pre-commit:
	@echo "ü™Ñ Running pre-commit hooks..."
	poetry run pre-commit run --all-files
